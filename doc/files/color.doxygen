/**
\page mizuiro_color

\section color_introduction Color Introduction

A color is an object that consists of color channels. For example, an RGB color
consists of the channels red, green and blue. This is called a layout.

There are two basic classes in mizuiro that can represent a color:
mizuiro::color::object which owns data and mizuiro::color::proxy which only
refers to data. The latter is important in cases where data comes from sources
of different types (like character arrays).

A color format is a combination of a color layout and additional information
that tells how a color is stored. For example, R8G8B8 is a homogenous color
format where each channel (red, green and blue) is represented by an uint8_t.

\section color_formats Color Formats

To use colors in Mizuiro, the first thing to do is to declare a color format.
Mizuiro comes with a bunch of predefined color formats but in this tutorial a
simple format, homogenous_static, will be used. To start off, the format's
headers must be included.

\snippet format.cpp includes_format

The homogenous_static header contains the definition of the homogenous_static
format, while the include/homogenous_static header contains all customization
points necessary to use the format.

Next, an rgb format is declared:

\snippet format.cpp format_definition

Here, a homogenous_static format is declared that uses uint8_t for each channel
and consists of red, green and blue. For the layout, the following include is
necessary:

\snippet format.cpp includes_layout

\section color_object Color Objects

A color object holds all data necessary to represent a color of a given type.

\snippet format.cpp includes_object

\snippet format.cpp object_definition

To initialize such a color object, special initialization syntax is used that
is available from the init namespace.

\snippet format.cpp includes_init

There are two forms of initialization:
<ul>
<li>Initializing the data directly and</li>
<li>initializing using a percentage value.</li>
</ul>
These can be mixed and matched for each channel.

\snippet format.cpp object_init

Accessing a color is done in a similar way:

\snippet format.cpp includes_access
\snippet format.cpp object_access


\section color_format_definition Color Format Definition

Common definitions:

true, false : Bool

normal, raw : Access

const, nonconst : Constness

apply_const : Type -> Constness -> Type

Formats and stores:

Given Channel, the type of channels, a color format has the following properties:

channel_value : Channel -> Type

For each c : Channel and T = channel_value(c):
  - T is totally ordered using <
  - channel_min, channel_max : Channel -> channel_value(Channel)
  - T's value range is [channel_min(c), channel_max(c)]

Store is a type with the following properties:

For each c : Channel, define the store's associated value
s(c) : channel_value(c) (c \in [channel_min(c), channel_max(c)])
such that:
  - pointer : (Access, Constness) -> Type
    A type representing a pointer to the store's memory.
  - store_data : Store -> Constness -> apply_const(Store, Constness) -> pointer(normal, Constness)
    Returns a pointer to the store's memory.
  - channel_reference : (Access, Constness, Channel) -> Type
    The type used to represent a reference to a channel.
  - extract_channel : Access -> Channel -> pointer(Access, Constness) -> channel_reference(Access, Constness, Channel)
    Provides access to a channel.

Very abstract semantics:

for each c : Channel and v : channel_value(c):

Define set(c, v) = extract_channel(normal, nonconst, store_data(nonconst, s)) <- v and
get(c) = extract_channel(normal, const, store_data(const, s)) then the following holds:

get(c) = s(c)

For all c' : Channel, c' != c
Let v' = s(c').
After set(c, v), it holds that
s(c) = v and s(c') = v'.

Additional store structure:

Difference = Int
Size = Nat

store_needs_init : Bool
init_store : Store

If store_needs_init is true, then init_store returns an initialized store. Some
color formats require this in order to access individual channels without
causing undefined behavior.

advance_pointer : pointer(Access, Constness) -> Difference -> pointer(access, constness)
pointer_difference : pointer(Access, Constness) -> pointer(access, constness) -> Difference
store_unit : Type
stride : Size

In C++:

apply_const (Type, nonconst) = Type
apply_const (Type, const) = make_const Type

make_const : Type -> Type
make_const t =
  u const & if t = u &,
  u const * if t = u *,
  t otherwise

store :: Format -> Type
needs_format_store :: Format -> Bool
pointer :: Access -> Format -> Constness -> Type
static_channels :: Format -> [StaticChannel]
layout :: Format -> Type

compare_channels :: FormatStore<Format> -> StaticChannel -> Channel -> bool
layout :: FormatStore<Format> -> layout<Format>
has_channel :: FormatStore<Format> -> Type -> bool


channel_index :: FormatStore<Format> -> Channel -> size_type TODO: Why do we need this?
*/
