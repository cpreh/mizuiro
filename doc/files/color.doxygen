/**
\page mizuiro_color

\section color_introduction Color Introduction

A color is an object that consists of color channels. For example, an RGB color
consists of the channels red, green and blue. This is called a layout.

There are two basic classes in mizuiro that can represent a color:
mizuiro::color::object which owns data and mizuiro::color::proxy which only
refers to data. The latter is important in cases where data comes from sources
of different types (like character arrays).

A color format is a combination of a color layout and additional information
that tells how a color is stored. For example, R8G8B8 is a homogenous color
format where each channel (red, green and blue) is represented by an uint8_t.

\section color_formats Color Formats

To use colors in Mizuiro, the first thing to do is to declare a color format.
Mizuiro comes with a bunch of predefined color formats but in this tutorial a
simple format, homogenous_static, will be used. To start off, the format's
headers must be included.

\snippet format.cpp includes_format

The homogenous_static header contains the definition of the homogenous_static
format, while the include/homogenous_static header contains all customization
points necessary to use the format.

Next, an rgb format is declared:

\snippet format.cpp format_definition

Here, a homogenous_static format is declared that uses uint8_t for each channel
and consists of red, green and blue. For the layout, the following include is
necessary:

\snippet format.cpp includes_layout

\section color_object Color Objects

A color object holds all data necessary to represent a color of a given type.

\snippet format.cpp includes_object

\snippet format.cpp object_definition

To initialize such a color object, special initialization syntax is used that
is available from the init namespace.

\snippet format.cpp includes_init

There are two forms of initialization:
<ul>
<li>Initializing the data directly and</li>
<li>initializing using a percentage value.</li>
</ul>
These can be mixed and matched for each channel.

\snippet format.cpp object_init

Accessing a color is done in a similar way:

\snippet format.cpp includes_access
\snippet format.cpp object_access


\section color_format_definition Color Format Definition

Syntax:

Common definitions:

\f$normal, raw : Access\f$

\f$const, nonconst : Constness\f$

\f$apply\_const : (Type, Constness) \to Type\f$

Formats and stores:

Given \f$Channel\f$, the type of channels, a color format has the following properties:

\f$valid\_channel\_type : Type \to Bool\f$

\f$valid\_channel\_type(Channel) = true\f$. It can be true for other, unspecified
types, as well.

\f$channel\_value : Channel \to Type\f$

For each \f$c : Channel\f$ and \f$T = channel_value(c)\f$:
  - \f$T\f$ is totally ordered using \f$<\f$
  - \f$channel\_min, channel\_max : Channel \to channel\_value(Channel)\f$
  - \f$T\f$'s value range is \f$[channel\_min(c), channel\_max(c)]\f$

\f$Store\f$ is a type with the following properties:

For each \f$c : Channel\f$, define the store's associated value
\f$s(c) : channel\_value(c) \in [channel\_min(c), channel\_max(c)]\f$
such that:
  - \f$pointer : (Access, Constness) \to Type\f$
    A type representing a pointer to the store's memory.
  - \f$store\_data : (cn : Constness) \Rightarrow apply\_const(Store, cn) \rightarrow pointer(normal, cn)\f$
    Returns a pointer to the store's memory.
  - \f$channel\_reference : valid\_channel\_type(C) \Rightarrow (Access, Constness, C) \rightarrow Type\f$
    The type used to represent a reference to a channel.
  - \f$extract\_channel : valid\_channel\_type(C) \Rightarrow (a : Access, cn : Constness) \Rightarrow (C, pointer(a, cn)) \rightarrow channel\_reference(a, cn, C)\f$
    Provides access to a channel.

Very abstract semantics:

For each \f$c : Channel\f$ and \f$v : channel_value(c)\f$:

Define \f[set(c, v) = extract\_channel(normal, nonconst)(c, store\_data(nonconst)(s)) \leftarrow v\f] and
\f[get(c) = extract\_channel(normal, const)(store\_data(const)(s))\f] then the following holds:

get(c) = s(c)

For all c' : Channel, c' != c
Let v' = s(c').
After set(c, v), it holds that
s(c) = v and s(c') = v'.

Additional store structure:

store_needs_init : Bool
init_store : Store

space : Type ???

If store_needs_init is true, then init_store returns an initialized store. Some
color formats require this in order to access individual channels without
causing undefined behavior.

Dynamic channel arrangments and channel iteration:

For every c : Channel, there is a d(c) : DynamicChannel.

needs_format_store : Bool

has_channel : valid_channel_type(C) => C \to Bool
static_channels : [Channel]
channels : [DynamicChannel]

compare_channels : valid_channel_type(C) => Channel \to C \to Bool
For each c1, c2 : Channel, compare_channels(c1, c2) = true iff c1 = c2.

In C++:

apply_const (Type, nonconst) = Type
apply_const (Type, const) = make_const Type

make_const : Type \to Type
make_const t =
  u const & if t = u &,
  u const * if t = u *,
  t otherwise

*/
