/**
\page mizuiro_color

\section color_introduction Color Introduction

A color is an object that consists of color channels. For example, an RGB color
consists of the channels red, green and blue. This is called a layout.

There are two basic classes in mizuiro that can represent a color:
mizuiro::color::object which owns data and mizuiro::color::proxy which only
refers to data. The latter is important in cases where data comes from sources
of different types (like character arrays).

A color format is a combination of a color layout and additional information
that tells how a color is stored. For example, R8G8B8 is a homogenous color
format where each channel (red, green and blue) is represented by an uint8_t.

\section color_formats Color Formats

To use colors in Mizuiro, the first thing to do is to declare a color format.
Mizuiro comes with a bunch of predefined color formats but in this tutorial a
simple format, homogenous_static, will be used. To start off, the format's
headers must be included.

\snippet format.cpp includes_format

The homogenous_static header contains the definition of the homogenous_static
format, while the include/homogenous_static header contains all customization
points necessary to use the format.

Next, an rgb format is declared:

\snippet format.cpp format_definition

Here, a homogenous_static format is declared that uses uint8_t for each channel
and consists of red, green and blue. For the layout, the following include is
necessary:

\snippet format.cpp includes_layout

\section color_object Color Objects

A color object holds all data necessary to represent a color of a given type.

\snippet format.cpp includes_object

\snippet format.cpp object_definition

To initialize such a color object, special initialization syntax is used that
is available from the init namespace.

\snippet format.cpp includes_init

There are two forms of initialization:
<ul>
<li>Initializing the data directly and</li>
<li>initializing using a percentage value.</li>
</ul>
These can be mixed and matched for each channel.

\snippet format.cpp object_init

Accessing a color is done in a similar way:

\snippet format.cpp includes_access
\snippet format.cpp object_access


\section color_format_definition Color Format Definition

Syntax:

A judgment is of the form \f$a : A\f$ and means that \f$a\f$ has type \f$A\f$.

\f$Type\f$ is called the universe of types.

If \f$A : Type\f$ and \f$B : Type\f$, then \f$A \rightarrow B : Type\f$. If \f$A_1 : Type, \ldots, A_n : Type\f$,
then \f$\prod_{A_i}^n : Type\f$.

\f$true, false : Bool\f$

Variables \f$X_1, X_2, \ldots\f$.

\f$ \Gamma \triangleright a : T\f$ is called a conditional judgment.

\f$\Gamma\f$ is a partial function from variables to types. \f$[]\f$ denotes the constant undefined function.

\f$\Gamma[\prod_{X_i : T_i}^n](X) = \begin{cases} T_i & if X = X_i \\ \Gamma(X) & otherwise\end{cases}\f$

Derivation rules:

If \f$a : A\f$, then \f$[] \triangleright a : A\f$.

From \f$\Gamma \triangleright a : A\f$ we can conclude \f$a : A\f$ if there are
no free variables in \f$a\f$ (TODO: Define this properly?).

\f$\Gamma \triangleright X : \Gamma(X)\f$

\f$\Gamma \triangleright \prod_{X_i : T_i}^n \Rightarrow e : T\f$
if \f$\Gamma[\prod_{X_i : T_i}^n] \triangleright e : T\f$

If \f$f : \prod_{A_i}^n \rightarrow T\f$ and
\f$\Gamma \triangleright a_i : A_i\f$ for \f$i = 1, \ldots, n\f$ then
\f$\Gamma \triangleright f(\prod_{a_i}^n) : T\f$

\f$\Gamma \triangleright g : (f(X) \Rightarrow T)\f$ if \f$f : Type \rightarrow Bool\f$
and for every \f$T' : Type\f$ with \f$f(T') = true\f$ it follows that
\f$\Gamma[(X : T')] \triangleright g : T\f$.

Common definitions:

normal, raw : Access

const, nonconst : Constness

apply_const : (Type, Constness) -> Type

Formats and stores:

Given Channel, the type of channels, a color format has the following properties:

valid_channel_type : Type -> Bool

valid_channel_type(Channel) = true. It can be true for other, unspecified
types, as well.

channel_value : Channel -> Type

For each c : Channel and T = channel_value(c):
  - T is totally ordered using <
  - channel_min, channel_max : Channel -> channel_value(Channel)
  - T's value range is [channel_min(c), channel_max(c)]

Store is a type with the following properties:

For each c : Channel, define the store's associated value
s(c) : channel_value(c) (c \in [channel_min(c), channel_max(c)])
such that:
  - pointer : (Access, Constness) -> Type
    A type representing a pointer to the store's memory.
  - store_data : (cn : Constness) => apply_const(Store, cn) -> pointer(normal, cn)
    Returns a pointer to the store's memory.
  - channel_reference : valid_channel_type(C) => (Access, Constness, C) -> Type
    The type used to represent a reference to a channel.
  - extract_channel : valid_channel_type(C) => (a : Access, cn : Constness) => C -> pointer(a, cn) -> channel_reference(a, cn, C)
    Provides access to a channel.

Very abstract semantics:

For each c : Channel and v : channel_value(c):

Define set(c, v) = extract_channel[normal, nonconst](c, store_data(nonconst)(s)) <- v and
get(c) = extract_channel(normal, const, store_data(const)(s)) then the following holds:

get(c) = s(c)

For all c' : Channel, c' != c
Let v' = s(c').
After set(c, v), it holds that
s(c) = v and s(c') = v'.

Additional store structure:

store_needs_init : Bool
init_store : Store

space : Type ???

If store_needs_init is true, then init_store returns an initialized store. Some
color formats require this in order to access individual channels without
causing undefined behavior.

Dynamic channel arrangments and channel iteration:

For every c : Channel, there is a d(c) : DynamicChannel.

needs_format_store : Bool

has_channel : valid_channel_type(C) => C -> Bool
static_channels : [Channel]
channels : [DynamicChannel]

compare_channels : valid_channel_type(C) => Channel -> C -> Bool
For each c1, c2 : Channel, compare_channels(c1, c2) = true iff c1 = c2.

In C++:

apply_const (Type, nonconst) = Type
apply_const (Type, const) = make_const Type

make_const : Type -> Type
make_const t =
  u const & if t = u &,
  u const * if t = u *,
  t otherwise

*/
